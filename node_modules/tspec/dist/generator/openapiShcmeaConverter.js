"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToOpenapiSchemas = void 0;
const json_schema_to_openapi_schema_1 = __importDefault(require("json-schema-to-openapi-schema")); // TODO: 이게 정말 필요한건지 체크 필요.
const isSchemaNullableOnly = (s) => (Object.keys(s).filter((key) => s[key] !== undefined).length === 1 && s.nullable);
const convertCombinedNullableInner = (schema, field) => {
    const types = schema[field] || [];
    const nullable = types.some((s) => isSchemaNullableOnly(s)) || undefined;
    return {
        ...schema,
        [field]: types.filter((s) => !isSchemaNullableOnly(s)),
        nullable,
    };
};
/** NOTE(hyeonseong): when anyOf or oneOf contains null, it should be nullable. */
const handleCombinedNullable = (schema) => {
    if (schema.anyOf) {
        return convertCombinedNullableInner(schema, 'anyOf');
    }
    if (schema.oneOf) {
        return convertCombinedNullableInner(schema, 'oneOf');
    }
    return schema;
};
const convertToNullableSchema = (schema) => {
    if (schema.type && !Array.isArray(schema.type) && schema.type === 'null') {
        return {
            ...schema,
            type: undefined,
            nullable: true,
        };
    }
    if (schema.type && Array.isArray(schema.type) && schema.type.length > 1) {
        const nullable = schema.type.includes('null');
        const types = schema.type.filter((type) => type !== 'null');
        if (types.length === 1) {
            return {
                ...schema,
                type: types[0],
                nullable,
            };
        }
        return {
            ...schema,
            type: undefined,
            oneOf: schema.type
                .filter((type) => type !== 'null')
                .map((type) => ({ ...schema, type })),
            nullable,
        };
    }
    return schema;
};
const handleExamples = (schema) => {
    if (schema.examples) {
        const { examples, ...rest } = schema;
        return {
            ...rest,
            example: Array.isArray(examples) ? examples[0] : examples,
        };
    }
    return schema;
};
const convertToOpenapiTypes = (schema) => {
    if (Array.isArray(schema)) {
        return schema.map((s) => convertToOpenapiTypes(s));
    }
    if (schema && typeof schema === 'object') {
        const nullableSchema = convertToNullableSchema(schema);
        const convertedSchema = Object.fromEntries(Object.entries(nullableSchema).map(([key, value]) => [key, convertToOpenapiTypes(value)]));
        const handlers = [handleCombinedNullable, handleExamples];
        return handlers.reduce((acc, handler) => handler(acc), convertedSchema);
    }
    return schema;
};
const findAllRefAndReplace = (schema, nameMapping) => {
    if (Array.isArray(schema)) {
        return schema.map((s) => findAllRefAndReplace(s, nameMapping));
    }
    if (schema && typeof schema === 'object') {
        if (schema.$ref) {
            const [, schemaName] = schema.$ref.split('#/definitions/');
            return {
                ...schema,
                $ref: `#/components/schemas/${nameMapping[schemaName]}`,
            };
        }
        return Object.fromEntries(Object.entries(schema).map(([key, value]) => [key, findAllRefAndReplace(value, nameMapping)]));
    }
    return schema;
};
const escapeSchemaNames = (schemas) => {
    const escapedNameMapping = Object.fromEntries(Object.keys(schemas).map((schemaName) => (
    // only contain the characters A-Z a-z 0-9 - . _
    [schemaName, schemaName.replace(/[^A-Za-z0-9_.-]/g, '_')])));
    const escapedSchemas = Object.fromEntries(Object.entries(schemas).map(([schemaName, schema]) => ([escapedNameMapping[schemaName], schema])));
    // eslint-disable-next-line max-len
    return findAllRefAndReplace(escapedSchemas, escapedNameMapping); // TODO: fix types
};
const convertToOpenapiSchemas = async (jsonSchemas) => {
    const convertedJsonSchemas = convertToOpenapiTypes(jsonSchemas);
    const openapiSchemas = await (0, json_schema_to_openapi_schema_1.default)(convertedJsonSchemas);
    return escapeSchemaNames(openapiSchemas);
};
exports.convertToOpenapiSchemas = convertToOpenapiSchemas;
//# sourceMappingURL=openapiShcmeaConverter.js.map