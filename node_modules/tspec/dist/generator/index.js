"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTspec = exports.DEBUG = void 0;
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = require("path");
const debug_1 = __importDefault(require("debug"));
const glob_1 = require("glob");
// eslint-disable-next-line import/no-extraneous-dependencies
const typescript_1 = __importDefault(require("typescript"));
const TJS = __importStar(require("typescript-json-schema"));
const types_1 = require("../utils/types");
const openapiGenerator_1 = require("./openapiGenerator");
const openapiShcmeaConverter_1 = require("./openapiShcmeaConverter");
exports.DEBUG = (0, debug_1.default)('tspec');
const isNodeExported = (node) => (
// eslint-disable-next-line no-bitwise
(typescript_1.default.getCombinedModifierFlags(node) & typescript_1.default.ModifierFlags.Export) !== 0
    || (!!node.parent && node.parent.kind === typescript_1.default.SyntaxKind.SourceFile));
const getTspecSignatures = (p) => {
    const entryPoints = p
        .getRootFileNames()
        .map((entryPointName) => p.getSourceFile(entryPointName)).filter(types_1.isDefined);
    const names = [];
    entryPoints.forEach((srcFile) => {
        srcFile.forEachChild((node) => {
            var _a, _b, _c;
            if (!isNodeExported(node)) {
                return;
            }
            // NOTE(hyeonseong): typescript 5.0 changed node kind of type alias declaration.
            // if (
            //   !ts.isTypeAliasDeclaration(node)
            //   || !ts.isTypeReferenceNode(node.type)
            // ) {
            //   return;
            // }
            if (((_c = (_b = (_a = node.type) === null || _a === void 0 ? void 0 : _a.typeName) === null || _b === void 0 ? void 0 : _b.right) === null || _c === void 0 ? void 0 : _c.escapedText) !== 'DefineApiSpec') {
                return;
            }
            const name = node.name.escapedText;
            if (names.includes(name)) {
                throw new Error(`Duplicate name: ${name}`);
            }
            names.push(name);
        });
    });
    return names;
};
const getCompilerOptions = (tsconfigPath) => {
    const { config, error } = typescript_1.default.readConfigFile(tsconfigPath, typescript_1.default.sys.readFile);
    if (error) {
        throw new Error(error.messageText);
    }
    return {
        ...config.compilerOptions,
        noEmit: true,
    };
};
const getDefaultProgramFiles = (compilerOptions) => {
    const { rootDir, rootDirs } = compilerOptions;
    return [rootDir, ...(rootDirs || [])].filter(types_1.isDefined)
        .flatMap((r) => [`${r}/*.ts`, `${r}/**/*.ts`]);
};
const getProgramFiles = (compilerOptions, specPathGlobs) => {
    const srcGlobs = specPathGlobs || getDefaultProgramFiles(compilerOptions);
    return [...new Set(srcGlobs.flatMap((g) => glob_1.glob.sync(g)))];
};
/**
 * 제대로 동작하지 않는 케이스..?
 * 1. Partial of Record
 * export type BlockRegions = Partial<Record<'es' | 'en', { blockAt: string }>>;
 */
const getOpenapiSchemas = async (tsconfigPath, specPathGlobs, ignoreErrors) => {
    const compilerOptions = getCompilerOptions(tsconfigPath);
    (0, exports.DEBUG)({ compilerOptions });
    const files = getProgramFiles(compilerOptions, specPathGlobs);
    (0, exports.DEBUG)({ files });
    const program = TJS.getProgramFromFiles(files, compilerOptions);
    const tjsSettings = {
        required: true,
        noExtraProps: true,
        strictNullChecks: true,
        ignoreErrors: ignoreErrors || true,
        esModuleInterop: compilerOptions.esModuleInterop,
        // rejectDateType: true,
        validationKeywords: ['example'],
    };
    (0, exports.DEBUG)({ tjsSettings });
    const generator = TJS.buildGenerator(program, tjsSettings);
    (0, types_1.assertIsDefined)(generator);
    const tspecSymbols = getTspecSignatures(program);
    (0, exports.DEBUG)({ tspecSymbols });
    const { definitions: jsonSchemas } = generator.getSchemaForSymbols(tspecSymbols);
    (0, types_1.assertIsDefined)(jsonSchemas);
    (0, exports.DEBUG)({ schemaKeys: Object.keys(jsonSchemas) });
    (0, exports.DEBUG)({ jsonSchemas });
    const openapiSchemas = await (0, openapiShcmeaConverter_1.convertToOpenapiSchemas)(jsonSchemas);
    return { openapiSchemas, tspecSymbols };
};
const getOpenapiSchemasOnly = (openapiSchemas, tspecSymbols) => {
    const tspecPathSchemas = tspecSymbols.flatMap((tspecSymbol) => {
        const paths = openapiSchemas[tspecSymbol].properties || {};
        (0, exports.DEBUG)({ tspecSymbol, paths });
        return Object.keys(paths).map((path) => {
            const obj = paths[path];
            if ('$ref' in obj) {
                const [, schemaName] = obj.$ref.split('#/components/schemas/');
                return schemaName;
            }
            return undefined;
        });
    });
    return Object.fromEntries(Object.entries(openapiSchemas).filter(([key]) => (!tspecSymbols.includes(key) && !tspecPathSchemas.includes(key))));
};
const generateTspec = async (params = {}) => {
    var _a, _b, _c, _d;
    const { openapiSchemas, tspecSymbols, } = await getOpenapiSchemas(params.tsconfigPath || 'tsconfig.json', params.specPathGlobs, params.ignoreErrors);
    const paths = (0, openapiGenerator_1.getOpenapiPaths)(openapiSchemas, tspecSymbols);
    const schemas = getOpenapiSchemasOnly(openapiSchemas, tspecSymbols);
    const openapi = {
        info: {
            title: ((_a = params.openapi) === null || _a === void 0 ? void 0 : _a.title) || 'Tspec API',
            version: ((_b = params.openapi) === null || _b === void 0 ? void 0 : _b.version) || '0.0.1',
        },
        openapi: (params.specVersion === 3 && '3.0.3') || '3.0.3',
        paths,
        components: {
            schemas,
            securitySchemes: (_c = params.openapi) === null || _c === void 0 ? void 0 : _c.securityDefinitions,
        },
        servers: (_d = params.openapi) === null || _d === void 0 ? void 0 : _d.servers,
    };
    if (params.outputPath) {
        await promises_1.default.mkdir((0, path_1.dirname)(params.outputPath), { recursive: true });
        await promises_1.default.writeFile(params.outputPath, JSON.stringify(openapi, null, 2));
    }
    return openapi;
};
exports.generateTspec = generateTspec;
//# sourceMappingURL=index.js.map